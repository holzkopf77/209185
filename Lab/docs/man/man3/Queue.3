.TH "Queue" 3 "Thu Mar 19 2015" "Version 1.0" "Lab 2" \" -*- nroff -*-
.ad l
.nh
.SH NAME
Queue \- 
.SH SYNOPSIS
.br
.PP
.PP
\fC#include <queue\&.h>\fP
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "void \fBadd\fP (std::fstream &openFile, int fileSize)"
.br
.RI "\fIAdding new element to the rear part of queue\&. \fP"
.ti -1c
.RI "\fBQueue\fP (\fBInputFiles\fP &file, \fBBenchmark\fP &queueTest)"
.br
.RI "\fIA constructor\&. \fP"
.ti -1c
.RI "\fB~Queue\fP ()"
.br
.RI "\fIA deconstructor\&. \fP"
.in -1c
.SS "Private Attributes"

.in +1c
.ti -1c
.RI "int \fBfront\fP"
.br
.ti -1c
.RI "int * \fBqueueTab\fP"
.br
.ti -1c
.RI "int \fBrear\fP"
.br
.in -1c
.SH "Detailed Description"
.PP 
An implementation of queue based on dynamically created table\&. Info based on http://www.studytonight.com/data-structures/queue-data-structure 
.SH "Constructor & Destructor Documentation"
.PP 
.SS "Queue::Queue (\fBInputFiles\fP & file, \fBBenchmark\fP & queueTest)"

.PP
A constructor\&. 
.PP
.nf
10                                                   {
11     // open file for data in root
12     std::fstream openFile;
13     // take name of this file
14     std::string fileName;
15     // file size
16     int fileSize;
17     // average time from test
18     long double avrgTime;
19 
20     for (int i = 0; i < file\&.return_number_files() - FIRST_ARGUMENT; i++){
21         fileName = file\&.return_file_name(i);
22         fileSize = file\&.return_file_size(i);
23         for (int i = 0; i < 10; i++){
24             openFile\&.open(fileName + "\&.txt");
25             // Check if file is opened correctly
26             assert(openFile\&.is_open() && "I can't open this file\&.");
27 
28             this->queueTab = new int[fileSize];
29             this->front = 0;
30             this->rear = 0;
31 
32             queueTest\&.test(fileSize, openFile, this);
33 
34             //initial again for next test
35             this->~Queue();
36             this->front = 0;
37             this->rear = 0;
38             openFile\&.close();
39         }
40         //generate raport
41         avrgTime = queueTest\&.getAvr(queueTest\&.testTimes);
42         queueTest\&.generateRaport(avrgTime, fileSize, fileName, QUEUE);
43     }
44 }
.fi
.SS "Queue::~Queue ()"

.PP
A deconstructor\&. 
.PP
.nf
47              {
48     //clear everything
49     queueTab = NULL;
50     delete[] queueTab;
51 }
.fi
.SH "Member Function Documentation"
.PP 
.SS "Queue::add (std::fstream & openFile, int fileSize)"

.PP
Adding new element to the rear part of queue\&. Adding new element, on the rear part, move this pointer to the next element\&.
.PP
\fBParameters:\fP
.RS 4
\fIopenFile\fP a pointer to the opened file 
.br
\fIfileSize\fP a size of opened file 
.RE
.PP

.PP
.nf
55                                                  {
56     // temporary data container
57     int tempData;
58     int counter = 0;
59 
60     while (openFile >> tempData){
61         counter++;
62         //check if there is some place in queue
63         if (counter > fileSize){
64             std::cout << " Queue is full! Program is going to be terminated" << std::endl;
65             std::cin\&.get();
66             exit(true);
67         }
68         else{
69             if (this->rear)
70                 // add element on the rear part of queue
71                 this->queueTab[this->rear] = tempData;
72             // move rear poiner
73             // if it move behind queue, make it on the front\&.
74             this->rear = (this->rear + 1) % fileSize;
75         }
76     }
77 }
.fi
.SH "Member Data Documentation"
.PP 
.SS "Queue::front\fC [private]\fP"
A head of queue position 
.SS "Queue::queueTab\fC [private]\fP"
A dynamic container for elements of queue 
.SS "Queue::rear\fC [private]\fP"
A tail of queue position 

.SH "Author"
.PP 
Generated automatically by Doxygen for Lab 2 from the source code\&.
