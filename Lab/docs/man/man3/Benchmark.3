.TH "Benchmark" 3 "Thu Mar 19 2015" "Version 1.0" "Lab 2" \" -*- nroff -*-
.ad l
.nh
.SH NAME
Benchmark \- 
.SH SYNOPSIS
.br
.PP
.PP
\fC#include <benchmark_frm\&.h>\fP
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "\fBBenchmark\fP ()"
.br
.ti -1c
.RI "\fBBenchmark\fP (const \fBBenchmark\fP &copy)"
.br
.ti -1c
.RI "void \fBshow_testTimes_v\fP ()"
.br
.RI "\fIshow filled vector with test times \fP"
.ti -1c
.RI "void \fBtest\fP (\fBInputFiles\fP files)"
.br
.ti -1c
.RI "void \fBtest\fP (std::fstream &file, \fBNode\fP *root)"
.br
.ti -1c
.RI "void \fBtest\fP (int fileSize, std::fstream &openFile, \fBQueue\fP *newQueue)"
.br
.ti -1c
.RI "void \fBtest\fP (std::fstream &openFile, \fBList\fP *newList)"
.br
.ti -1c
.RI "void \fBtest\fP (int fileSize, std::fstream &openFile, \fBStack\fP *newStack)"
.br
.in -1c
.SS "Private Member Functions"

.in +1c
.ti -1c
.RI "void \fBgenerateRaport\fP (long double nextTime, int size)"
.br
.ti -1c
.RI "void \fBgenerateRaport\fP (long double avgTime, int size, std::string fileName, \fBdata_type\fP type)"
.br
.ti -1c
.RI "long double \fBgetAvr\fP (std::vector< long double >times)"
.br
.RI "\fIMeasures the average duration from 10 samples\&. \fP"
.ti -1c
.RI "void \fBmeasureTime\fP (int *dataTable, int dataSize)"
.br
.RI "\fIMeasures the duration of the work of assignment function\&. \fP"
.in -1c
.SS "Private Attributes"

.in +1c
.ti -1c
.RI "std::vector< long double > \fBtestTimes\fP"
.br
.RI "\fIA container for calculated times\&. \fP"
.in -1c
.SS "Friends"

.in +1c
.ti -1c
.RI "class \fBList\fP"
.br
.ti -1c
.RI "class \fBQueue\fP"
.br
.ti -1c
.RI "class \fBStack\fP"
.br
.ti -1c
.RI "class \fBTree\fP"
.br
.in -1c
.SH "Detailed Description"
.PP 
Making a framework for testing inserted data structure\&. Using time to estimate computational complexity\&. 
.SH "Constructor & Destructor Documentation"
.PP 
.SS "Benchmark::Benchmark ()"

.PP
.nf
15                     {
16     ;
17 }
.fi
.SS "Benchmark::Benchmark (const \fBBenchmark\fP & copy)"

.PP
.nf
11                                          {
12     testTimes = copy\&.testTimes;
13 }
.fi
.SH "Member Function Documentation"
.PP 
.SS "void Benchmark::generateRaport (long double nextTime, int size)\fC [private]\fP"

.PP
\fBTodo\fP
.RS 4
FILE OVERWRITING, NEED TO IMPLEMENT NEW NAMES 
.RE
.PP

.PP
.nf
101                                                             {
103     std::ofstream raportFile;
104     std::string stringNextTime = std::to_string(nextTime);
105 
106     // \&.xls as excel file format
107     raportFile\&.open("test\&.xls", std::ios::in | std::ios::app);
108         assert(raportFile\&.is_open() && ("I can't open file\&."));
109     // need to change '\&.' on ',' due to excel string format 
110     boost::algorithm::replace_first(stringNextTime, "\&.", ",");
111     
112     raportFile << size << "\n" << stringNextTime << "\n";
113     raportFile\&.close();
114 }
.fi
.SS "void Benchmark::generateRaport (long double avgTime, int size, std::string fileName, \fBdata_type\fP type)\fC [private]\fP"

.PP
.nf
116                                                                                                {
117     std::ofstream raportFile;
118     std::string stringNextTime = std::to_string(avgTime);
119 
120     if (type == BIN_TREE){
121         // \&.xls as excel file format
122         raportFile\&.open("test_btree\&.xls", std::ios::in | std::ios::app);
123         assert(raportFile\&.is_open() && ("I can't open file\&."));
124         // need to change '\&.' on ',' due to excel string format 
125         boost::algorithm::replace_first(stringNextTime, "\&.", ",");
126 
127         raportFile << size << "\n" << stringNextTime << "\n";
128         raportFile\&.close();
129 
130         std::cout << "(BinaryTree) For file " << "> " << fileName << " <" << " (size: " << size << ")" << " average test time (10 times) was: " << avgTime << std::endl;
131     }
132     else if (type == QUEUE){
133         // \&.xls as excel file format
134         raportFile\&.open("test_queue\&.xls", std::ios::in | std::ios::app);
135         assert(raportFile\&.is_open() && ("I can't open file\&."));
136         // need to change '\&.' on ',' due to excel string format 
137         boost::algorithm::replace_first(stringNextTime, "\&.", ",");
138 
139         raportFile << size << "\n" << stringNextTime << "\n";
140         raportFile\&.close();
141 
142         std::cout << "(Queue) For file " << "> " << fileName << " <" << " (size: " << size << ")" << " average test time (10 times) was: " << avgTime << std::endl;
143     }
144     else if (type == LIST){
145         // \&.xls as excel file format
146         raportFile\&.open("test_list\&.xls", std::ios::in | std::ios::app);
147             assert(raportFile\&.is_open() && ("I can't open file\&."));
148         // need to change '\&.' on ',' due to excel string format 
149         boost::algorithm::replace_first(stringNextTime, "\&.", ",");
150 
151         raportFile << size << "\n" << stringNextTime << "\n";
152         raportFile\&.close();
153 
154         std::cout << "(List) For file " << "> " << fileName << " <" << " (size: " << size << ")" << " average test time (10 times) was: " << avgTime << std::endl;
155     }
156     else if (type == STACK){
157         // \&.xls as excel file format
158         raportFile\&.open("test_stack\&.xls", std::ios::in | std::ios::app);
159         assert(raportFile\&.is_open() && ("I can't open file\&."));
160         // need to change '\&.' on ',' due to excel string format 
161         boost::algorithm::replace_first(stringNextTime, "\&.", ",");
162 
163         raportFile << size << "\n" << stringNextTime << "\n";
164         raportFile\&.close();
165 
166         std::cout << "(Stack) For file " << "> " << fileName << " <" << " (size: " << size << ")" << " average test time (10 times) was: " << avgTime << std::endl;
167     }
168 }
.fi
.SS "Benchmark::getAvr (std::vector< long double > times)\fC [private]\fP"

.PP
Measures the average duration from 10 samples\&. 
.PP
\fBParameters:\fP
.RS 4
\fItimes\fP A container with times from tests\&. 
.RE
.PP

.PP
.nf
170                                                         {
171     long double avrg = 0\&.0;
172 
173     //add 10 values, than count average
174     for (int i = 0; i < (signed)times\&.size(); i++){
175         avrg += times[i];
176     }
177 
178     avrg /= (long double)times\&.size();
179     return avrg;
180 }
.fi
.SS "Benchmark::measureTime (int * dataTable, int dataSize)\fC [private]\fP"

.PP
Measures the duration of the work of assignment function\&. Version for dynamic table
.PP
\fBParameters:\fP
.RS 4
\fIdataTable\fP A container with random integers from earlier made files\&. 
.br
\fIdataSize\fP A size of the file\&. 
.RE
.PP

.PP
.nf
182                                                        {
183     // container for counted working times
184     std::vector<long double> estimateTimes;
185 
186     for (int j = 0; j < 10; j++){
187         // Here starts the timer
188         boost::timer::cpu_timer startTime;
189         for (int i = 0; i < dataSize; i++){
190             dataTable[i] *= 2;
191         }
192         // Here it ends
193         boost::timer::cpu_times endTime = startTime\&.elapsed();
194         // add new time to the vector
195         estimateTimes\&.push_back(static_cast<long double>(endTime\&.wall * SEC));
196     }
197     // for better display
198     std::cout\&.fixed;
199     long double DurTime = getAvr(estimateTimes);
200     std::cout << "Time (average, 10 samples) for " << dataSize << " elements: " << DurTime << " sec"<< std::endl;
201     generateRaport(DurTime, dataSize);
202 }
.fi
.SS "Benchmark::show_testTimes_v ()"

.PP
show filled vector with test times 
.PP
.nf
204                                 {
205     for (int i = 0; i < (signed)this->testTimes\&.size(); i++){
206         std::cout << testTimes[i] << std::endl;
207     }
208 }
.fi
.SS "void Benchmark::test (\fBInputFiles\fP files)"

.PP
.nf
19                                     {
20     // temp memory container
21     int* tabForData = NULL;
22     int tempValue = 0;
23     std::fstream newFile;
24 
25     for (int i = 0; i < files\&.return_number_files() - FIRST_ARGUMENT; i++){
26         // Opening file + making new table with content
27         tabForData = new int[files\&.return_file_size(i)];
28         newFile\&.open((files\&.return_file_name(i) + "\&.txt"), std::ios::in);
29 
30         // Checking if file is opened correctly
31         assert(newFile\&.is_open() && ("I can't open file\&."));
32 
33         for (int j = 0; j < files\&.return_file_size(i); j++){
34             newFile >> tempValue;
35             tabForData[j] = tempValue;
36         }
37         newFile\&.close();
38 
39         // Testing time here
40         measureTime(tabForData, files\&.return_file_size(i));
41         delete[] tabForData;
42     }
43 }
.fi
.SS "void Benchmark::test (std::fstream & file, \fBNode\fP * root)"

.PP
.nf
46                                                 {
47     // temporary data container
48     int tempData;
49 
50     //here starts timer
51     boost::timer::cpu_timer startTime;
52     while (file >> tempData)
53         root->add(file, tempData);
54     //here ends
55     boost::timer::cpu_times endTime = startTime\&.elapsed();
56 
57     //put new time to the vector
58     this->testTimes\&.push_back(static_cast<long double>(endTime\&.wall * SEC));
59 }
.fi
.SS "void Benchmark::test (int fileSize, std::fstream & openFile, \fBQueue\fP * newQueue)"

.PP
.nf
62                                                                        {
63 
64     //here starts timer
65     boost::timer::cpu_timer startTime;
66     newQueue->add(openFile, fileSize);
67     //here ends
68     boost::timer::cpu_times endTime = startTime\&.elapsed();
69 
70     //put new time to the vector
71     this->testTimes\&.push_back(static_cast<long double>(endTime\&.wall * SEC));
72 }
.fi
.SS "void Benchmark::test (std::fstream & openFile, \fBList\fP * newList)"

.PP
.nf
75                                                        {
76 
77     //here starts timer
78     boost::timer::cpu_timer startTime;
79     newList->add(openFile);
80     //here ends
81     boost::timer::cpu_times endTime = startTime\&.elapsed();
82 
83     //put new time to the vector
84     this->testTimes\&.push_back(static_cast<long double>(endTime\&.wall * SEC));
85 }
.fi
.SS "void Benchmark::test (int fileSize, std::fstream & openFile, \fBStack\fP * newStack)"

.PP
.nf
88                                                                        {
89     
90     //here starts timer
91     boost::timer::cpu_timer startTime;
92     newStack->add(openFile, fileSize);
93     //here ends
94     boost::timer::cpu_times endTime = startTime\&.elapsed();
95 
96     //put new time to the vector
97     this->testTimes\&.push_back(static_cast<long double>(endTime\&.wall * SEC));
98 }
.fi
.SH "Friends And Related Function Documentation"
.PP 
.SS "friend class \fBList\fP\fC [friend]\fP"

.SS "friend class \fBQueue\fP\fC [friend]\fP"

.SS "friend class \fBStack\fP\fC [friend]\fP"

.SS "friend class \fBTree\fP\fC [friend]\fP"

.SH "Member Data Documentation"
.PP 
.SS "Benchmark::testTimes\fC [private]\fP"

.PP
A container for calculated times\&. 

.SH "Author"
.PP 
Generated automatically by Doxygen for Lab 2 from the source code\&.
