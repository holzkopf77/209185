.TH "Tree" 3 "Thu Mar 19 2015" "Version 1.0" "Lab 2" \" -*- nroff -*-
.ad l
.nh
.SH NAME
Tree \- 
.SH SYNOPSIS
.br
.PP
.PP
\fC#include <tree\&.h>\fP
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "void \fBshow_tree\fP ()"
.br
.RI "\fIshow 3 levels from tree, starting from root node\&. \fP"
.ti -1c
.RI "\fBTree\fP (\fBInputFiles\fP &file, \fBBenchmark\fP &TreeTest)"
.br
.RI "\fIconstructor \fP"
.ti -1c
.RI "\fB~Tree\fP ()"
.br
.RI "\fIdeconstructor \fP"
.in -1c
.SS "Private Attributes"

.in +1c
.ti -1c
.RI "\fBNode\fP * \fBroot\fP"
.br
.RI "\fIRoot node of the tree\&. \fP"
.in -1c
.SH "Detailed Description"
.PP 
.SH "Constructor & Destructor Documentation"
.PP 
.SS "Tree::Tree (\fBInputFiles\fP & file, \fBBenchmark\fP & TreeTest)"

.PP
constructor Open file with random integers (range: 0 - 99999), create root node, than add new branch nodes depends on data from file\&. 
.PP
\fBTodo\fP
.RS 4
memory problems, maybe new deconstructor? 
.RE
.PP

.PP
.nf
8                                                {
11     // open file for data in root
12     std::fstream openFile;
13     // container for first data
14     int rootData;
15     // take name of this file
16     std::string fileName;
17     // file size
18     int fileSize;
19     // average time from test
20     long double avrgTime;
21 
22     for (int i = 0; i < file\&.return_number_files() - FIRST_ARGUMENT; i++){
23         fileName = file\&.return_file_name(i);
24         fileSize = file\&.return_file_size(i);
25         for (int i = 0; i < 10; i++){
26             openFile\&.open(fileName + "\&.txt");
27             // Check if file is opened correctly
28             assert(openFile\&.is_open() && "I can't open this file\&.");
29 
30             // create root node, put there first value from file
31             openFile >> rootData;
32             root = new Node(rootData);
33 
34             //start test here
35             treeTest\&.test(openFile, root);
36 
37             //initial again for next test
38             root->~Node();
39             root = NULL;
40             rootData = 0;
41             openFile\&.close();
42         }
43         avrgTime = treeTest\&.getAvr(treeTest\&.testTimes);
44         treeTest\&.generateRaport(avrgTime, fileSize, fileName, BIN_TREE);
45     }
46 }
.fi
.SS "Tree::~Tree ()"

.PP
deconstructor Empty all memory space for tree 
.PP
.nf
50            {
51     delete root;
52 }
.fi
.SH "Member Function Documentation"
.PP 
.SS "Tree::show_tree ()"

.PP
show 3 levels from tree, starting from root node\&. 
.PP
.nf
55 {
56     //root 1lvl
57     std::cout << "root: " << root->get_data_container() << std::endl;
58     //2lvl
59     if (root->return_left() != NULL)
60         std::cout << "root(L): " << root->return_left()->get_data_container() << "\t";
61     if (root->return_right() != NULL)
62         std::cout << "root(R): " << root->return_right()->get_data_container() << std::endl;
63     //3lvl
64     if (root->return_left()->return_left() != NULL)
65         std::cout << "root(LL2): " << root->return_left()->return_left()->get_data_container() << "\t";
66     if (root->return_left()->return_right() != NULL)
67         std::cout << "root(LR2): " << root->return_left()->return_right()->get_data_container() << "\t";
68     if (root->return_right()->return_left() != NULL)
69         std::cout << "root(RL2): " << root->return_right()->return_left()->get_data_container() << "\t";
70     if (root->return_right()->return_right() != NULL)
71         std::cout << "root(RR2): " << root->return_right()->return_right()->get_data_container() << std::endl;
72 
73 }
.fi
.SH "Member Data Documentation"
.PP 
.SS "Tree::root\fC [private]\fP"

.PP
Root node of the tree\&. 

.SH "Author"
.PP 
Generated automatically by Doxygen for Lab 2 from the source code\&.
